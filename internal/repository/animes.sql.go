// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: animes.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllGenres = `-- name: GetAllGenres :many
SELECT DISTINCT
  trim(unnested) AS genre
FROM
  animes,
  unnest(string_to_array(genre, ',')) AS unnested
ORDER BY
  genre
`

func (q *Queries) GetAllGenres(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var genre string
		if err := rows.Scan(&genre); err != nil {
			return nil, err
		}
		items = append(items, genre)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeByGenre = `-- name: GetAnimeByGenre :many
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
WHERE
  genre ILIKE '%' || $3 || '%'
ORDER BY
  updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAnimeByGenreParams struct {
	Limit  int32
	Offset int32
	Genre  pgtype.Text
}

func (q *Queries) GetAnimeByGenre(ctx context.Context, arg GetAnimeByGenreParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimeByGenre, arg.Limit, arg.Offset, arg.Genre)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeByGenreCount = `-- name: GetAnimeByGenreCount :one
SELECT
  COUNT(*)
FROM
  animes
WHERE
  genre ILIKE '%' || $1 || '%'
`

func (q *Queries) GetAnimeByGenreCount(ctx context.Context, genre pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getAnimeByGenreCount, genre)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAnimeByHiAnimeId = `-- name: GetAnimeByHiAnimeId :one
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
WHERE
  hi_anime_id = $1
`

func (q *Queries) GetAnimeByHiAnimeId(ctx context.Context, hiAnimeID string) (Anime, error) {
	row := q.db.QueryRow(ctx, getAnimeByHiAnimeId, hiAnimeID)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.Season,
		&i.SeasonYear,
	)
	return i, err
}

const getAnimeById = `-- name: GetAnimeById :one
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
WHERE
  id = $1
`

func (q *Queries) GetAnimeById(ctx context.Context, id string) (Anime, error) {
	row := q.db.QueryRow(ctx, getAnimeById, id)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.Season,
		&i.SeasonYear,
	)
	return i, err
}

const getAnimeByMalId = `-- name: GetAnimeByMalId :one
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
WHERE
  mal_id = $1
`

func (q *Queries) GetAnimeByMalId(ctx context.Context, malID pgtype.Int4) (Anime, error) {
	row := q.db.QueryRow(ctx, getAnimeByMalId, malID)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.Season,
		&i.SeasonYear,
	)
	return i, err
}

const getAnimeBySeason = `-- name: GetAnimeBySeason :many
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
WHERE
  season = $3::season
ORDER BY
  season_year DESC
LIMIT $1 OFFSET $2
`

type GetAnimeBySeasonParams struct {
	Limit  int32
	Offset int32
	Season Season
}

func (q *Queries) GetAnimeBySeason(ctx context.Context, arg GetAnimeBySeasonParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimeBySeason, arg.Limit, arg.Offset, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeBySeasonAndYear = `-- name: GetAnimeBySeasonAndYear :many
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
WHERE
  season = $3::season
  AND season_year = $4::int
ORDER BY
  updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAnimeBySeasonAndYearParams struct {
	Limit      int32
	Offset     int32
	Season     Season
	SeasonYear int32
}

func (q *Queries) GetAnimeBySeasonAndYear(ctx context.Context, arg GetAnimeBySeasonAndYearParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimeBySeasonAndYear,
		arg.Limit,
		arg.Offset,
		arg.Season,
		arg.SeasonYear,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeBySeasonAndYearCount = `-- name: GetAnimeBySeasonAndYearCount :one
SELECT
  COUNT(*)
FROM
  animes
WHERE
  season = $1::season
  AND season_year = $2::int
`

type GetAnimeBySeasonAndYearCountParams struct {
	Season     Season
	SeasonYear int32
}

func (q *Queries) GetAnimeBySeasonAndYearCount(ctx context.Context, arg GetAnimeBySeasonAndYearCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getAnimeBySeasonAndYearCount, arg.Season, arg.SeasonYear)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAnimeBySeasonCount = `-- name: GetAnimeBySeasonCount :one
SELECT
  COUNT(*)
FROM
  animes
WHERE
  season = $1::season
`

func (q *Queries) GetAnimeBySeasonCount(ctx context.Context, season Season) (int64, error) {
	row := q.db.QueryRow(ctx, getAnimeBySeasonCount, season)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAnimeByYear = `-- name: GetAnimeByYear :many
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
WHERE
  season_year = $3::int
ORDER BY
  updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAnimeByYearParams struct {
	Limit      int32
	Offset     int32
	SeasonYear int32
}

func (q *Queries) GetAnimeByYear(ctx context.Context, arg GetAnimeByYearParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimeByYear, arg.Limit, arg.Offset, arg.SeasonYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeByYearCount = `-- name: GetAnimeByYearCount :one
SELECT
  COUNT(*)
FROM
  animes
WHERE
  season_year = $1::int
`

func (q *Queries) GetAnimeByYearCount(ctx context.Context, seasonYear int32) (int64, error) {
	row := q.db.QueryRow(ctx, getAnimeByYearCount, seasonYear)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAnimeMetadataByMalId = `-- name: GetAnimeMetadataByMalId :one
SELECT
  mal_id, description, main_picture_url, media_type, rating, airing_status, avg_episode_duration, total_episodes, studio, rank, mean, scoringusers, popularity, airing_start_date, airing_end_date, source, trailer_embed_url, season_year, season, created_at, updated_at
FROM
  anime_metadata
WHERE
  mal_id = $1
`

func (q *Queries) GetAnimeMetadataByMalId(ctx context.Context, malID int32) (AnimeMetadatum, error) {
	row := q.db.QueryRow(ctx, getAnimeMetadataByMalId, malID)
	var i AnimeMetadatum
	err := row.Scan(
		&i.MalID,
		&i.Description,
		&i.MainPictureUrl,
		&i.MediaType,
		&i.Rating,
		&i.AiringStatus,
		&i.AvgEpisodeDuration,
		&i.TotalEpisodes,
		&i.Studio,
		&i.Rank,
		&i.Mean,
		&i.Scoringusers,
		&i.Popularity,
		&i.AiringStartDate,
		&i.AiringEndDate,
		&i.Source,
		&i.TrailerEmbedUrl,
		&i.SeasonYear,
		&i.Season,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAnimesByHiAnimeIds = `-- name: GetAnimesByHiAnimeIds :many
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
WHERE
  hi_anime_id = ANY ($1::text[])
ORDER BY
  updated_at DESC
`

func (q *Queries) GetAnimesByHiAnimeIds(ctx context.Context, hiAnimeIds []string) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimesByHiAnimeIds, hiAnimeIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimesByMalIds = `-- name: GetAnimesByMalIds :many
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
WHERE
  mal_id = ANY ($1::int[])
ORDER BY
  updated_at DESC
`

func (q *Queries) GetAnimesByMalIds(ctx context.Context, malIds []int32) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimesByMalIds, malIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountOfAnimes = `-- name: GetCountOfAnimes :one
SELECT
  COUNT(*) AS count
FROM
  animes
`

func (q *Queries) GetCountOfAnimes(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOfAnimes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRandomAnime = `-- name: GetRandomAnime :one
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
ORDER BY
  RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomAnime(ctx context.Context) (Anime, error) {
	row := q.db.QueryRow(ctx, getRandomAnime)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.Season,
		&i.SeasonYear,
	)
	return i, err
}

const getRandomAnimeByGenre = `-- name: GetRandomAnimeByGenre :one
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
WHERE
  genre ILIKE '%' || $1 || '%'
ORDER BY
  RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomAnimeByGenre(ctx context.Context, genre pgtype.Text) (Anime, error) {
	row := q.db.QueryRow(ctx, getRandomAnimeByGenre, genre)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.Season,
		&i.SeasonYear,
	)
	return i, err
}

const getRecentlyUpdatedAnimes = `-- name: GetRecentlyUpdatedAnimes :many
SELECT
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
FROM
  animes
WHERE
  animes.mal_id IS NOT NULL
  OR animes.mal_id != 0
ORDER BY
  updated_at DESC
LIMIT $1 OFFSET $2
`

type GetRecentlyUpdatedAnimesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetRecentlyUpdatedAnimes(ctx context.Context, arg GetRecentlyUpdatedAnimesParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getRecentlyUpdatedAnimes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentlyUpdatedAnimesCount = `-- name: GetRecentlyUpdatedAnimesCount :one
SELECT
  COUNT(*)
FROM
  animes
WHERE
  animes.mal_id IS NOT NULL
  OR animes.mal_id != 0
`

func (q *Queries) GetRecentlyUpdatedAnimesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getRecentlyUpdatedAnimesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertAnime = `-- name: InsertAnime :exec
INSERT INTO animes(ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, season, season_year)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, COALESCE($9, NOW()), COALESCE($10, NOW()), $11, $12)
RETURNING
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
`

type InsertAnimeParams struct {
	Ename       string
	Jname       string
	ImageUrl    string
	Genre       string
	HiAnimeID   string
	MalID       pgtype.Int4
	AnilistID   pgtype.Int4
	LastEpisode int32
	CreatedAt   interface{}
	UpdatedAt   interface{}
	Season      Season
	SeasonYear  int32
}

func (q *Queries) InsertAnime(ctx context.Context, arg InsertAnimeParams) error {
	_, err := q.db.Exec(ctx, insertAnime,
		arg.Ename,
		arg.Jname,
		arg.ImageUrl,
		arg.Genre,
		arg.HiAnimeID,
		arg.MalID,
		arg.AnilistID,
		arg.LastEpisode,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Season,
		arg.SeasonYear,
	)
	return err
}

type InsertMultipleAnimesParams struct {
	Ename       string
	Jname       string
	ImageUrl    string
	Genre       string
	HiAnimeID   string
	MalID       pgtype.Int4
	AnilistID   pgtype.Int4
	LastEpisode int32
	Season      Season
	SeasonYear  int32
}

const searchAnimes = `-- name: SearchAnimes :many
SELECT
  animes.id, animes.ename, animes.jname, animes.image_url, animes.genre, animes.hi_anime_id, animes.mal_id, animes.anilist_id, animes.last_episode, animes.created_at, animes.updated_at, animes.search_vector, animes.season, animes.season_year,
  ts_rank(animes.search_vector, plainto_tsquery($3)) AS query_rank
FROM
  animes
WHERE ($3 = ''
  OR $3 IS NULL
  OR ename % $3
  OR jname % $3
  OR search_vector @@ plainto_tsquery('english', $3))
AND ($4 = ''
  OR $4 IS NULL
  OR genre ILIKE '%' || $4 || '%')
AND animes.mal_id IS NOT NULL
ORDER BY
  query_rank DESC
LIMIT $1 OFFSET $2
`

type SearchAnimesParams struct {
	Limit  int32
	Offset int32
	Query  string
	Genre  interface{}
}

type SearchAnimesRow struct {
	ID           string
	Ename        string
	Jname        string
	ImageUrl     string
	Genre        string
	HiAnimeID    string
	MalID        pgtype.Int4
	AnilistID    pgtype.Int4
	LastEpisode  int32
	CreatedAt    pgtype.Timestamp
	UpdatedAt    pgtype.Timestamp
	SearchVector string
	Season       Season
	SeasonYear   int32
	QueryRank    float32
}

func (q *Queries) SearchAnimes(ctx context.Context, arg SearchAnimesParams) ([]SearchAnimesRow, error) {
	rows, err := q.db.Query(ctx, searchAnimes,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.Genre,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchAnimesRow
	for rows.Next() {
		var i SearchAnimesRow
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.QueryRank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAnimesCount = `-- name: SearchAnimesCount :one
SELECT
  COUNT(*)
FROM
  animes
WHERE ($1 = ''
  OR $1 IS NULL
  OR ename % $1
  OR jname % $1
  OR search_vector @@ plainto_tsquery('english', $1))
AND ($2 = ''
  OR $2 IS NULL
  OR genre ILIKE '%' || $2 || '%')
AND animes.mal_id IS NOT NULL
`

type SearchAnimesCountParams struct {
	Query interface{}
	Genre interface{}
}

func (q *Queries) SearchAnimesCount(ctx context.Context, arg SearchAnimesCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, searchAnimesCount, arg.Query, arg.Genre)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateAnime = `-- name: UpdateAnime :exec
UPDATE
  animes
SET
  ename = $1,
  jname = $2,
  image_url = $3,
  genre = $4,
  hi_anime_id = $5,
  mal_id = $6,
  anilist_id = $7,
  last_episode = $8,
  updated_at = COALESCE($9, NOW()),
  season = $10,
  season_year = $11
WHERE
  id = $12
RETURNING
  id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year
`

type UpdateAnimeParams struct {
	Ename       string
	Jname       string
	ImageUrl    string
	Genre       string
	HiAnimeID   string
	MalID       pgtype.Int4
	AnilistID   pgtype.Int4
	LastEpisode int32
	UpdatedAt   pgtype.Timestamp
	Season      Season
	SeasonYear  int32
	ID          string
}

func (q *Queries) UpdateAnime(ctx context.Context, arg UpdateAnimeParams) error {
	_, err := q.db.Exec(ctx, updateAnime,
		arg.Ename,
		arg.Jname,
		arg.ImageUrl,
		arg.Genre,
		arg.HiAnimeID,
		arg.MalID,
		arg.AnilistID,
		arg.LastEpisode,
		arg.UpdatedAt,
		arg.Season,
		arg.SeasonYear,
		arg.ID,
	)
	return err
}

const updateAnimeMetadataTrailer = `-- name: UpdateAnimeMetadataTrailer :exec
UPDATE
  anime_metadata
SET
  trailer_embed_url = $1,
  updated_at = NOW()
WHERE
  mal_id = $2
RETURNING
  mal_id, description, main_picture_url, media_type, rating, airing_status, avg_episode_duration, total_episodes, studio, rank, mean, scoringusers, popularity, airing_start_date, airing_end_date, source, trailer_embed_url, season_year, season, created_at, updated_at
`

type UpdateAnimeMetadataTrailerParams struct {
	TrailerEmbedUrl pgtype.Text
	MalID           int32
}

func (q *Queries) UpdateAnimeMetadataTrailer(ctx context.Context, arg UpdateAnimeMetadataTrailerParams) error {
	_, err := q.db.Exec(ctx, updateAnimeMetadataTrailer, arg.TrailerEmbedUrl, arg.MalID)
	return err
}

const upsertAnimeMetadata = `-- name: UpsertAnimeMetadata :exec
INSERT INTO anime_metadata(mal_id, description, main_picture_url, media_type, rating, airing_status, avg_episode_duration, total_episodes, studio, rank, mean, scoringUsers, popularity, airing_start_date, airing_end_date, source, trailer_embed_url, season_year, season)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
ON CONFLICT (mal_id)
  DO UPDATE SET
    description = EXCLUDED.description,
    main_picture_url = EXCLUDED.main_picture_url,
    media_type = EXCLUDED.media_type,
    rating = EXCLUDED.rating,
    airing_status = EXCLUDED.airing_status,
    avg_episode_duration = EXCLUDED.avg_episode_duration,
    total_episodes = EXCLUDED.total_episodes,
    studio = EXCLUDED.studio,
    rank = EXCLUDED.rank,
    mean = EXCLUDED.mean,
    scoringUsers = EXCLUDED.scoringUsers,
    popularity = EXCLUDED.popularity,
    airing_start_date = EXCLUDED.airing_start_date,
    airing_end_date = EXCLUDED.airing_end_date,
    source = EXCLUDED.source,
    trailer_embed_url = EXCLUDED.trailer_embed_url,
    season_year = EXCLUDED.season_year,
    season = EXCLUDED.season,
    updated_at = NOW()
  RETURNING
    mal_id, description, main_picture_url, media_type, rating, airing_status, avg_episode_duration, total_episodes, studio, rank, mean, scoringusers, popularity, airing_start_date, airing_end_date, source, trailer_embed_url, season_year, season, created_at, updated_at
`

type UpsertAnimeMetadataParams struct {
	MalID              int32
	Description        pgtype.Text
	MainPictureUrl     pgtype.Text
	MediaType          pgtype.Text
	Rating             Rating
	AiringStatus       AiringStatus
	AvgEpisodeDuration pgtype.Int4
	TotalEpisodes      pgtype.Int4
	Studio             pgtype.Text
	Rank               pgtype.Int4
	Mean               pgtype.Float8
	Scoringusers       pgtype.Int4
	Popularity         pgtype.Int4
	AiringStartDate    pgtype.Text
	AiringEndDate      pgtype.Text
	Source             pgtype.Text
	TrailerEmbedUrl    pgtype.Text
	SeasonYear         pgtype.Int4
	Season             Season
}

func (q *Queries) UpsertAnimeMetadata(ctx context.Context, arg UpsertAnimeMetadataParams) error {
	_, err := q.db.Exec(ctx, upsertAnimeMetadata,
		arg.MalID,
		arg.Description,
		arg.MainPictureUrl,
		arg.MediaType,
		arg.Rating,
		arg.AiringStatus,
		arg.AvgEpisodeDuration,
		arg.TotalEpisodes,
		arg.Studio,
		arg.Rank,
		arg.Mean,
		arg.Scoringusers,
		arg.Popularity,
		arg.AiringStartDate,
		arg.AiringEndDate,
		arg.Source,
		arg.TrailerEmbedUrl,
		arg.SeasonYear,
		arg.Season,
	)
	return err
}
