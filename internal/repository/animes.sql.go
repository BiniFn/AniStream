// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: animes.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllGenres = `-- name: GetAllGenres :many
SELECT DISTINCT
    trim(unnested) AS genre
FROM
    animes,
    unnest(string_to_array(genre, ',')) AS unnested
ORDER BY
    genre
`

func (q *Queries) GetAllGenres(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var genre string
		if err := rows.Scan(&genre); err != nil {
			return nil, err
		}
		items = append(items, genre)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeByGenre = `-- name: GetAnimeByGenre :many
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    genre ILIKE '%' || $3 || '%'
ORDER BY
    updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAnimeByGenreParams struct {
	Limit  int32
	Offset int32
	Genre  pgtype.Text
}

func (q *Queries) GetAnimeByGenre(ctx context.Context, arg GetAnimeByGenreParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimeByGenre, arg.Limit, arg.Offset, arg.Genre)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.GenresArr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeByGenreCount = `-- name: GetAnimeByGenreCount :one
SELECT
    COUNT(*)
FROM
    animes
WHERE
    genre ILIKE '%' || $1 || '%'
`

func (q *Queries) GetAnimeByGenreCount(ctx context.Context, genre pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getAnimeByGenreCount, genre)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAnimeByHiAnimeId = `-- name: GetAnimeByHiAnimeId :one
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    hi_anime_id = $1
`

func (q *Queries) GetAnimeByHiAnimeId(ctx context.Context, hiAnimeID string) (Anime, error) {
	row := q.db.QueryRow(ctx, getAnimeByHiAnimeId, hiAnimeID)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.Season,
		&i.SeasonYear,
		&i.GenresArr,
	)
	return i, err
}

const getAnimeById = `-- name: GetAnimeById :one
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    id = $1
`

func (q *Queries) GetAnimeById(ctx context.Context, id string) (Anime, error) {
	row := q.db.QueryRow(ctx, getAnimeById, id)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.Season,
		&i.SeasonYear,
		&i.GenresArr,
	)
	return i, err
}

const getAnimeByMalId = `-- name: GetAnimeByMalId :many
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    mal_id = $1
`

func (q *Queries) GetAnimeByMalId(ctx context.Context, malID pgtype.Int4) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimeByMalId, malID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.GenresArr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeBySeason = `-- name: GetAnimeBySeason :many
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    season = $3::season
ORDER BY
    season_year DESC
LIMIT $1 OFFSET $2
`

type GetAnimeBySeasonParams struct {
	Limit  int32
	Offset int32
	Season Season
}

func (q *Queries) GetAnimeBySeason(ctx context.Context, arg GetAnimeBySeasonParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimeBySeason, arg.Limit, arg.Offset, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.GenresArr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeBySeasonAndYear = `-- name: GetAnimeBySeasonAndYear :many
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    season = $3::season
    AND season_year = $4::int
ORDER BY
    updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAnimeBySeasonAndYearParams struct {
	Limit      int32
	Offset     int32
	Season     Season
	SeasonYear int32
}

func (q *Queries) GetAnimeBySeasonAndYear(ctx context.Context, arg GetAnimeBySeasonAndYearParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimeBySeasonAndYear,
		arg.Limit,
		arg.Offset,
		arg.Season,
		arg.SeasonYear,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.GenresArr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeBySeasonAndYearCount = `-- name: GetAnimeBySeasonAndYearCount :one
SELECT
    COUNT(*)
FROM
    animes
WHERE
    season = $1::season
    AND season_year = $2::int
`

type GetAnimeBySeasonAndYearCountParams struct {
	Season     Season
	SeasonYear int32
}

func (q *Queries) GetAnimeBySeasonAndYearCount(ctx context.Context, arg GetAnimeBySeasonAndYearCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getAnimeBySeasonAndYearCount, arg.Season, arg.SeasonYear)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAnimeBySeasonCount = `-- name: GetAnimeBySeasonCount :one
SELECT
    COUNT(*)
FROM
    animes
WHERE
    season = $1::season
`

func (q *Queries) GetAnimeBySeasonCount(ctx context.Context, season Season) (int64, error) {
	row := q.db.QueryRow(ctx, getAnimeBySeasonCount, season)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAnimeByYear = `-- name: GetAnimeByYear :many
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    season_year = $3::int
ORDER BY
    updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAnimeByYearParams struct {
	Limit      int32
	Offset     int32
	SeasonYear int32
}

func (q *Queries) GetAnimeByYear(ctx context.Context, arg GetAnimeByYearParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimeByYear, arg.Limit, arg.Offset, arg.SeasonYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.GenresArr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeByYearCount = `-- name: GetAnimeByYearCount :one
SELECT
    COUNT(*)
FROM
    animes
WHERE
    season_year = $1::int
`

func (q *Queries) GetAnimeByYearCount(ctx context.Context, seasonYear int32) (int64, error) {
	row := q.db.QueryRow(ctx, getAnimeByYearCount, seasonYear)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAnimeCatalog = `-- name: GetAnimeCatalog :many
WITH p AS (
    SELECT
        -- normalized/trimmed search
        NULLIF (trim($9::text), '') AS q,
        -- normalized genres (lowercased, trimmed) or NULL
        CASE WHEN $10::text[] IS NULL THEN
            NULL
        ELSE
            (
                SELECT
                    array_agg(lower(trim(g)))
                FROM
                    unnest($10::text[]) AS u (g)
                WHERE
                    trim(g) <> '')
        END AS g,
        $11::text AS gm,
        $12::text AS sb,
        $13::text AS so
)
SELECT
    a.id, a.ename, a.jname, a.image_url, a.genre, a.hi_anime_id, a.mal_id, a.anilist_id, a.last_episode, a.created_at, a.updated_at, a.search_vector, a.season, a.season_year, a.genres_arr,
    l.id AS library_id,
    l.user_id AS library_user_id,
    l.anime_id AS library_anime_id,
    l.status AS library_status,
    l.watched_episodes AS library_watched_episodes,
    l.created_at AS library_created_at,
    l.updated_at AS library_updated_at,
    CASE WHEN p.q IS NOT NULL THEN
        ts_rank(a.search_vector, plainto_tsquery('english', p.q))
    ELSE
        NULL
    END AS query_rank
FROM
    animes a
    -- Only JOIN library when user_id is provided
    LEFT JOIN library l ON ($3::varchar IS NOT NULL
            AND a.id = l.anime_id
            AND l.user_id = $3::varchar)
    CROSS JOIN p
WHERE
    -- only MAL-linked rows
    (a.mal_id IS NOT NULL
        AND a.mal_id <> 0)
    -- search (skip when q is null)
    AND (p.q IS NULL
        OR a.ename % p.q
        OR a.jname % p.q
        OR a.search_vector @@ plainto_tsquery('english', p.q))
    -- seasons (skip when null)
    AND ($4::text[] IS NULL
        OR a.season = ANY ($4::season[]))
    -- years list (skip when null)
    AND ($5::int[] IS NULL
        OR a.season_year = ANY ($5::int[]))
    -- year range (skip each bound when null)
    AND ($6::int IS NULL
        OR a.season_year >= $6::int)
    AND ($7::int IS NULL
        OR a.season_year <= $7::int)
    -- genres ANY/ALL using generated genres_arr (skip when null/empty)
    AND (p.g IS NULL
        OR (
            CASE WHEN p.gm = 'all' THEN
                a.genres_arr @> p.g
            ELSE
                a.genres_arr && p.g
            END))
        -- Library-only filtering (when user_id provided, only show library entries)
        AND ($3::varchar IS NULL -- catalog mode
            OR l.user_id IS NOT NULL) -- library mode (must be in library)
        -- Library status filtering
        AND ($8::library_status IS NULL
            OR l.status = $8::library_status)
    ORDER BY
        -- relevance
        CASE WHEN p.sb = 'relevance'
            AND p.so = 'asc' THEN
            CASE WHEN p.q IS NOT NULL THEN
                ts_rank(a.search_vector, plainto_tsquery('english', p.q))
            END
        END ASC NULLS LAST,
        CASE WHEN p.sb = 'relevance'
            AND p.so = 'desc' THEN
            CASE WHEN p.q IS NOT NULL THEN
                ts_rank(a.search_vector, plainto_tsquery('english', p.q))
            END
        END DESC NULLS LAST,
        -- ename
        CASE WHEN p.sb = 'ename'
            AND p.so = 'asc' THEN
            a.ename
        END ASC NULLS LAST,
        CASE WHEN p.sb = 'ename'
            AND p.so = 'desc' THEN
            a.ename
        END DESC NULLS LAST,
        -- jname
        CASE WHEN p.sb = 'jname'
            AND p.so = 'asc' THEN
            a.jname
        END ASC NULLS LAST,
        CASE WHEN p.sb = 'jname'
            AND p.so = 'desc' THEN
            a.jname
        END DESC NULLS LAST,
        -- season
        CASE WHEN p.sb = 'season'
            AND p.so = 'asc' THEN
            a.season::text
        END ASC NULLS LAST,
        CASE WHEN p.sb = 'season'
            AND p.so = 'desc' THEN
            a.season::text
        END DESC NULLS LAST,
        -- year
        CASE WHEN p.sb = 'year'
            AND p.so = 'asc' THEN
            a.season_year
        END ASC NULLS LAST,
        CASE WHEN p.sb = 'year'
            AND p.so = 'desc' THEN
            a.season_year
        END DESC NULLS LAST,
        -- anime updated_at
        CASE WHEN p.sb = 'anime_updated_at'
            AND p.so = 'asc' THEN
            a.updated_at
        END ASC NULLS LAST,
        CASE WHEN p.sb = 'anime_updated_at'
            AND p.so = 'desc' THEN
            a.updated_at
        END DESC NULLS LAST,
        -- library updated_at (only when library is joined)
        CASE WHEN p.sb = 'library_updated_at'
            AND p.so = 'asc' THEN
            l.updated_at
        END ASC NULLS LAST,
        CASE WHEN p.sb = 'library_updated_at'
            AND p.so = 'desc' THEN
            l.updated_at
        END DESC NULLS LAST,
        -- legacy updated_at (maps to anime_updated_at for backward compatibility)
        CASE WHEN p.sb = 'updated_at'
            AND p.so = 'asc' THEN
            a.updated_at
        END ASC NULLS LAST,
        CASE WHEN p.sb = 'updated_at'
            AND p.so = 'desc' THEN
            a.updated_at
        END DESC NULLS LAST,
        -- stable tiebreakers (helpful for deterministic paging)
        a.updated_at DESC,
        a.id DESC
    LIMIT $1 OFFSET $2
`

type GetAnimeCatalogParams struct {
	Limit         int32
	Offset        int32
	UserID        pgtype.Text
	Seasons       []string
	Years         []int32
	YearMin       pgtype.Int4
	YearMax       pgtype.Int4
	LibraryStatus NullLibraryStatus
	Search        pgtype.Text
	Genres        []string
	GenresMode    pgtype.Text
	SortBy        pgtype.Text
	SortOrder     pgtype.Text
}

type GetAnimeCatalogRow struct {
	ID                     string
	Ename                  string
	Jname                  string
	ImageUrl               string
	Genre                  string
	HiAnimeID              string
	MalID                  pgtype.Int4
	AnilistID              pgtype.Int4
	LastEpisode            int32
	CreatedAt              pgtype.Timestamp
	UpdatedAt              pgtype.Timestamp
	SearchVector           string
	Season                 Season
	SeasonYear             int32
	GenresArr              []string
	LibraryID              pgtype.Text
	LibraryUserID          pgtype.Text
	LibraryAnimeID         pgtype.Text
	LibraryStatus          NullLibraryStatus
	LibraryWatchedEpisodes pgtype.Int4
	LibraryCreatedAt       pgtype.Timestamp
	LibraryUpdatedAt       pgtype.Timestamp
	QueryRank              interface{}
}

func (q *Queries) GetAnimeCatalog(ctx context.Context, arg GetAnimeCatalogParams) ([]GetAnimeCatalogRow, error) {
	rows, err := q.db.Query(ctx, getAnimeCatalog,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Seasons,
		arg.Years,
		arg.YearMin,
		arg.YearMax,
		arg.LibraryStatus,
		arg.Search,
		arg.Genres,
		arg.GenresMode,
		arg.SortBy,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAnimeCatalogRow
	for rows.Next() {
		var i GetAnimeCatalogRow
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.GenresArr,
			&i.LibraryID,
			&i.LibraryUserID,
			&i.LibraryAnimeID,
			&i.LibraryStatus,
			&i.LibraryWatchedEpisodes,
			&i.LibraryCreatedAt,
			&i.LibraryUpdatedAt,
			&i.QueryRank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeCatalogCount = `-- name: GetAnimeCatalogCount :one
WITH p AS (
    SELECT
        NULLIF (trim($7::text), '') AS q,
        CASE WHEN $8::text[] IS NULL THEN
            NULL
        ELSE
            (
                SELECT
                    array_agg(lower(trim(g)))
                FROM
                    unnest($8::text[]) AS u (g)
                WHERE
                    trim(g) <> '')
        END AS g,
        $9::text AS gm
)
SELECT
    COUNT(*)
FROM
    animes a
    -- Only JOIN library when user_id is provided
    LEFT JOIN library l ON ($1::varchar IS NOT NULL
            AND a.id = l.anime_id
            AND l.user_id = $1::varchar)
    CROSS JOIN p
WHERE
    -- only MAL-linked rows
    (a.mal_id IS NOT NULL
        AND a.mal_id <> 0)
    -- search (skip when q is null)
    AND (p.q IS NULL
        OR a.ename % p.q
        OR a.jname % p.q
        OR a.search_vector @@ plainto_tsquery('english', p.q))
    -- seasons (skip when null)
    AND ($2::text[] IS NULL
        OR a.season = ANY ($2::season[]))
    -- years list (skip when null)
    AND ($3::int[] IS NULL
        OR a.season_year = ANY ($3::int[]))
    -- year range (skip each bound when null)
    AND ($4::int IS NULL
        OR a.season_year >= $4::int)
    AND ($5::int IS NULL
        OR a.season_year <= $5::int)
    -- genres ANY/ALL using generated genres_arr (skip when null/empty)
    AND (p.g IS NULL
        OR (
            CASE WHEN p.gm = 'all' THEN
                a.genres_arr @> p.g
            ELSE
                a.genres_arr && p.g
            END))
        -- Library-only filtering (when user_id provided, only show library entries)
        AND ($1::varchar IS NULL -- catalog mode
            OR l.user_id IS NOT NULL) -- library mode (must be in library)
        -- Library status filtering
        AND ($6::library_status IS NULL
            OR l.status = $6::library_status)
`

type GetAnimeCatalogCountParams struct {
	UserID        pgtype.Text
	Seasons       []string
	Years         []int32
	YearMin       pgtype.Int4
	YearMax       pgtype.Int4
	LibraryStatus NullLibraryStatus
	Search        pgtype.Text
	Genres        []string
	GenresMode    pgtype.Text
}

func (q *Queries) GetAnimeCatalogCount(ctx context.Context, arg GetAnimeCatalogCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getAnimeCatalogCount,
		arg.UserID,
		arg.Seasons,
		arg.Years,
		arg.YearMin,
		arg.YearMax,
		arg.LibraryStatus,
		arg.Search,
		arg.Genres,
		arg.GenresMode,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAnimeMetadataByMalId = `-- name: GetAnimeMetadataByMalId :one
SELECT
    mal_id, description, main_picture_url, media_type, rating, airing_status, avg_episode_duration, total_episodes, studio, rank, mean, scoringusers, popularity, airing_start_date, airing_end_date, source, trailer_embed_url, season_year, season, created_at, updated_at
FROM
    anime_metadata
WHERE
    mal_id = $1
`

func (q *Queries) GetAnimeMetadataByMalId(ctx context.Context, malID int32) (AnimeMetadatum, error) {
	row := q.db.QueryRow(ctx, getAnimeMetadataByMalId, malID)
	var i AnimeMetadatum
	err := row.Scan(
		&i.MalID,
		&i.Description,
		&i.MainPictureUrl,
		&i.MediaType,
		&i.Rating,
		&i.AiringStatus,
		&i.AvgEpisodeDuration,
		&i.TotalEpisodes,
		&i.Studio,
		&i.Rank,
		&i.Mean,
		&i.Scoringusers,
		&i.Popularity,
		&i.AiringStartDate,
		&i.AiringEndDate,
		&i.Source,
		&i.TrailerEmbedUrl,
		&i.SeasonYear,
		&i.Season,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAnimeVariations = `-- name: GetAnimeVariations :many
SELECT
    animes.id, animes.ename, animes.jname, animes.image_url, animes.genre, animes.hi_anime_id, animes.mal_id, animes.anilist_id, animes.last_episode, animes.created_at, animes.updated_at, animes.search_vector, animes.season, animes.season_year, animes.genres_arr
FROM
    animes
WHERE
    mal_id = (
        SELECT
            a.mal_id
        FROM
            animes a
        WHERE
            a.id = $1)
    AND animes.id != $1
ORDER BY
    animes.created_at DESC
`

func (q *Queries) GetAnimeVariations(ctx context.Context, id string) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimeVariations, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.GenresArr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimesByHiAnimeIds = `-- name: GetAnimesByHiAnimeIds :many
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    hi_anime_id = ANY ($1::text[])
ORDER BY
    updated_at DESC
`

func (q *Queries) GetAnimesByHiAnimeIds(ctx context.Context, hiAnimeIds []string) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimesByHiAnimeIds, hiAnimeIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.GenresArr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimesByMalIds = `-- name: GetAnimesByMalIds :many
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    mal_id = ANY ($1::int[])
ORDER BY
    updated_at DESC
`

func (q *Queries) GetAnimesByMalIds(ctx context.Context, malIds []int32) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimesByMalIds, malIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.GenresArr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountOfAnimes = `-- name: GetCountOfAnimes :one
SELECT
    COUNT(*) AS count
FROM
    animes
`

func (q *Queries) GetCountOfAnimes(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOfAnimes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getGenrePreviews = `-- name: GetGenrePreviews :many
WITH g AS (
    SELECT DISTINCT
        unnest(a.genres_arr) AS genre
    FROM
        animes a
)
SELECT
    g.genre::text AS name,
    COALESCE(ARRAY (
            SELECT
                a2.image_url::text
            FROM animes a2
            WHERE
                a2.genres_arr @> ARRAY[g.genre]::text[] ORDER BY a2.season_year DESC, a2.updated_at DESC, a2.id DESC LIMIT 6), ARRAY[]::text[]) AS previews
FROM
    g
ORDER BY
    g.genre
`

type GetGenrePreviewsRow struct {
	Name     string
	Previews interface{}
}

func (q *Queries) GetGenrePreviews(ctx context.Context) ([]GetGenrePreviewsRow, error) {
	rows, err := q.db.Query(ctx, getGenrePreviews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGenrePreviewsRow
	for rows.Next() {
		var i GetGenrePreviewsRow
		if err := rows.Scan(&i.Name, &i.Previews); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomAnime = `-- name: GetRandomAnime :one
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    animes.mal_id IS NOT NULL
    OR animes.mal_id != 0
ORDER BY
    RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomAnime(ctx context.Context) (Anime, error) {
	row := q.db.QueryRow(ctx, getRandomAnime)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.Season,
		&i.SeasonYear,
		&i.GenresArr,
	)
	return i, err
}

const getRandomAnimeByGenre = `-- name: GetRandomAnimeByGenre :one
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    genre ILIKE '%' || $1 || '%'
    AND (animes.mal_id IS NOT NULL
        OR animes.mal_id != 0)
ORDER BY
    RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomAnimeByGenre(ctx context.Context, genre pgtype.Text) (Anime, error) {
	row := q.db.QueryRow(ctx, getRandomAnimeByGenre, genre)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.Season,
		&i.SeasonYear,
		&i.GenresArr,
	)
	return i, err
}

const getRecentlyUpdatedAnimes = `-- name: GetRecentlyUpdatedAnimes :many
SELECT
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
FROM
    animes
WHERE
    animes.mal_id IS NOT NULL
    OR animes.mal_id != 0
ORDER BY
    updated_at DESC
LIMIT $1 OFFSET $2
`

type GetRecentlyUpdatedAnimesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetRecentlyUpdatedAnimes(ctx context.Context, arg GetRecentlyUpdatedAnimesParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getRecentlyUpdatedAnimes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.GenresArr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentlyUpdatedAnimesCount = `-- name: GetRecentlyUpdatedAnimesCount :one
SELECT
    COUNT(*)
FROM
    animes
WHERE
    animes.mal_id IS NOT NULL
    OR animes.mal_id != 0
`

func (q *Queries) GetRecentlyUpdatedAnimesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getRecentlyUpdatedAnimesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertAnime = `-- name: InsertAnime :exec
INSERT INTO animes (ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, season, season_year)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, COALESCE($9, NOW()), COALESCE($10, NOW()), $11, $12)
RETURNING
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
`

type InsertAnimeParams struct {
	Ename       string
	Jname       string
	ImageUrl    string
	Genre       string
	HiAnimeID   string
	MalID       pgtype.Int4
	AnilistID   pgtype.Int4
	LastEpisode int32
	CreatedAt   interface{}
	UpdatedAt   interface{}
	Season      Season
	SeasonYear  int32
}

func (q *Queries) InsertAnime(ctx context.Context, arg InsertAnimeParams) error {
	_, err := q.db.Exec(ctx, insertAnime,
		arg.Ename,
		arg.Jname,
		arg.ImageUrl,
		arg.Genre,
		arg.HiAnimeID,
		arg.MalID,
		arg.AnilistID,
		arg.LastEpisode,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Season,
		arg.SeasonYear,
	)
	return err
}

type InsertMultipleAnimesParams struct {
	Ename       string
	Jname       string
	ImageUrl    string
	Genre       string
	HiAnimeID   string
	MalID       pgtype.Int4
	AnilistID   pgtype.Int4
	LastEpisode int32
	Season      Season
	SeasonYear  int32
}

const searchAnimes = `-- name: SearchAnimes :many
SELECT
    animes.id, animes.ename, animes.jname, animes.image_url, animes.genre, animes.hi_anime_id, animes.mal_id, animes.anilist_id, animes.last_episode, animes.created_at, animes.updated_at, animes.search_vector, animes.season, animes.season_year, animes.genres_arr,
    ts_rank(animes.search_vector, plainto_tsquery($3)) AS query_rank
FROM
    animes
WHERE ($3 = ''
    OR $3 IS NULL
    OR ename % $3
    OR jname % $3
    OR search_vector @@ plainto_tsquery('english', $3))
AND ($4 = ''
    OR $4 IS NULL
    OR genre ILIKE '%' || $4 || '%')
AND animes.mal_id IS NOT NULL
ORDER BY
    query_rank DESC
LIMIT $1 OFFSET $2
`

type SearchAnimesParams struct {
	Limit  int32
	Offset int32
	Query  string
	Genre  interface{}
}

type SearchAnimesRow struct {
	ID           string
	Ename        string
	Jname        string
	ImageUrl     string
	Genre        string
	HiAnimeID    string
	MalID        pgtype.Int4
	AnilistID    pgtype.Int4
	LastEpisode  int32
	CreatedAt    pgtype.Timestamp
	UpdatedAt    pgtype.Timestamp
	SearchVector string
	Season       Season
	SeasonYear   int32
	GenresArr    []string
	QueryRank    float32
}

func (q *Queries) SearchAnimes(ctx context.Context, arg SearchAnimesParams) ([]SearchAnimesRow, error) {
	rows, err := q.db.Query(ctx, searchAnimes,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.Genre,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchAnimesRow
	for rows.Next() {
		var i SearchAnimesRow
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.Season,
			&i.SeasonYear,
			&i.GenresArr,
			&i.QueryRank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAnimesCount = `-- name: SearchAnimesCount :one
SELECT
    COUNT(*)
FROM
    animes
WHERE ($1 = ''
    OR $1 IS NULL
    OR ename % $1
    OR jname % $1
    OR search_vector @@ plainto_tsquery('english', $1))
AND ($2 = ''
    OR $2 IS NULL
    OR genre ILIKE '%' || $2 || '%')
AND animes.mal_id IS NOT NULL
`

type SearchAnimesCountParams struct {
	Query interface{}
	Genre interface{}
}

func (q *Queries) SearchAnimesCount(ctx context.Context, arg SearchAnimesCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, searchAnimesCount, arg.Query, arg.Genre)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateAnime = `-- name: UpdateAnime :exec
UPDATE
    animes
SET
    ename = $1,
    jname = $2,
    image_url = $3,
    genre = $4,
    hi_anime_id = $5,
    mal_id = $6,
    anilist_id = $7,
    last_episode = $8,
    updated_at = COALESCE($9, NOW()),
    season = $10,
    season_year = $11
WHERE
    id = $12
RETURNING
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
`

type UpdateAnimeParams struct {
	Ename       string
	Jname       string
	ImageUrl    string
	Genre       string
	HiAnimeID   string
	MalID       pgtype.Int4
	AnilistID   pgtype.Int4
	LastEpisode int32
	UpdatedAt   pgtype.Timestamp
	Season      Season
	SeasonYear  int32
	ID          string
}

func (q *Queries) UpdateAnime(ctx context.Context, arg UpdateAnimeParams) error {
	_, err := q.db.Exec(ctx, updateAnime,
		arg.Ename,
		arg.Jname,
		arg.ImageUrl,
		arg.Genre,
		arg.HiAnimeID,
		arg.MalID,
		arg.AnilistID,
		arg.LastEpisode,
		arg.UpdatedAt,
		arg.Season,
		arg.SeasonYear,
		arg.ID,
	)
	return err
}

const updateAnimeAnilistId = `-- name: UpdateAnimeAnilistId :exec
UPDATE
    animes
SET
    anilist_id = $1
WHERE
    id = $2
RETURNING
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
`

type UpdateAnimeAnilistIdParams struct {
	AnilistID pgtype.Int4
	ID        string
}

func (q *Queries) UpdateAnimeAnilistId(ctx context.Context, arg UpdateAnimeAnilistIdParams) error {
	_, err := q.db.Exec(ctx, updateAnimeAnilistId, arg.AnilistID, arg.ID)
	return err
}

const updateAnimeMetadataTrailer = `-- name: UpdateAnimeMetadataTrailer :exec
UPDATE
    anime_metadata
SET
    trailer_embed_url = $1,
    updated_at = NOW()
WHERE
    mal_id = $2
RETURNING
    mal_id, description, main_picture_url, media_type, rating, airing_status, avg_episode_duration, total_episodes, studio, rank, mean, scoringusers, popularity, airing_start_date, airing_end_date, source, trailer_embed_url, season_year, season, created_at, updated_at
`

type UpdateAnimeMetadataTrailerParams struct {
	TrailerEmbedUrl pgtype.Text
	MalID           int32
}

func (q *Queries) UpdateAnimeMetadataTrailer(ctx context.Context, arg UpdateAnimeMetadataTrailerParams) error {
	_, err := q.db.Exec(ctx, updateAnimeMetadataTrailer, arg.TrailerEmbedUrl, arg.MalID)
	return err
}

const updateAnimeSeasons = `-- name: UpdateAnimeSeasons :exec
UPDATE
    animes
SET
    season = $1,
    season_year = $2
WHERE
    id = $3
RETURNING
    id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector, season, season_year, genres_arr
`

type UpdateAnimeSeasonsParams struct {
	Season     Season
	SeasonYear int32
	ID         string
}

func (q *Queries) UpdateAnimeSeasons(ctx context.Context, arg UpdateAnimeSeasonsParams) error {
	_, err := q.db.Exec(ctx, updateAnimeSeasons, arg.Season, arg.SeasonYear, arg.ID)
	return err
}

const upsertAnimeMetadata = `-- name: UpsertAnimeMetadata :exec
INSERT INTO anime_metadata (mal_id, description, main_picture_url, media_type, rating, airing_status, avg_episode_duration, total_episodes, studio, rank, mean, scoringUsers, popularity, airing_start_date, airing_end_date, source, trailer_embed_url, season_year, season)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
ON CONFLICT (mal_id)
    DO UPDATE SET
        description = EXCLUDED.description,
        main_picture_url = EXCLUDED.main_picture_url,
        media_type = EXCLUDED.media_type,
        rating = EXCLUDED.rating,
        airing_status = EXCLUDED.airing_status,
        avg_episode_duration = EXCLUDED.avg_episode_duration,
        total_episodes = EXCLUDED.total_episodes,
        studio = EXCLUDED.studio,
        rank = EXCLUDED.rank,
        mean = EXCLUDED.mean,
        scoringUsers = EXCLUDED.scoringUsers,
        popularity = EXCLUDED.popularity,
        airing_start_date = EXCLUDED.airing_start_date,
        airing_end_date = EXCLUDED.airing_end_date,
        source = EXCLUDED.source,
        trailer_embed_url = EXCLUDED.trailer_embed_url,
        season_year = EXCLUDED.season_year,
        season = EXCLUDED.season,
        updated_at = NOW()
    RETURNING
        mal_id, description, main_picture_url, media_type, rating, airing_status, avg_episode_duration, total_episodes, studio, rank, mean, scoringusers, popularity, airing_start_date, airing_end_date, source, trailer_embed_url, season_year, season, created_at, updated_at
`

type UpsertAnimeMetadataParams struct {
	MalID              int32
	Description        pgtype.Text
	MainPictureUrl     pgtype.Text
	MediaType          pgtype.Text
	Rating             Rating
	AiringStatus       AiringStatus
	AvgEpisodeDuration pgtype.Int4
	TotalEpisodes      pgtype.Int4
	Studio             pgtype.Text
	Rank               pgtype.Int4
	Mean               pgtype.Float8
	Scoringusers       pgtype.Int4
	Popularity         pgtype.Int4
	AiringStartDate    pgtype.Text
	AiringEndDate      pgtype.Text
	Source             pgtype.Text
	TrailerEmbedUrl    pgtype.Text
	SeasonYear         pgtype.Int4
	Season             Season
}

func (q *Queries) UpsertAnimeMetadata(ctx context.Context, arg UpsertAnimeMetadataParams) error {
	_, err := q.db.Exec(ctx, upsertAnimeMetadata,
		arg.MalID,
		arg.Description,
		arg.MainPictureUrl,
		arg.MediaType,
		arg.Rating,
		arg.AiringStatus,
		arg.AvgEpisodeDuration,
		arg.TotalEpisodes,
		arg.Studio,
		arg.Rank,
		arg.Mean,
		arg.Scoringusers,
		arg.Popularity,
		arg.AiringStartDate,
		arg.AiringEndDate,
		arg.Source,
		arg.TrailerEmbedUrl,
		arg.SeasonYear,
		arg.Season,
	)
	return err
}
