// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: animes.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllGenres = `-- name: GetAllGenres :many
SELECT DISTINCT trim(unnested) AS genre
FROM animes,
  unnest(string_to_array(genre, ',')) AS unnested
`

func (q *Queries) GetAllGenres(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var genre string
		if err := rows.Scan(&genre); err != nil {
			return nil, err
		}
		items = append(items, genre)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeByAnilistId = `-- name: GetAnimeByAnilistId :one
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
WHERE anilist_id = $1
`

func (q *Queries) GetAnimeByAnilistId(ctx context.Context, anilistID pgtype.Int4) (Anime, error) {
	row := q.db.QueryRow(ctx, getAnimeByAnilistId, anilistID)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const getAnimeByGenre = `-- name: GetAnimeByGenre :many
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
WHERE genre ILIKE '%' || $3 || '%'
ORDER BY updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAnimeByGenreParams struct {
	Limit  int32
	Offset int32
	Genre  pgtype.Text
}

func (q *Queries) GetAnimeByGenre(ctx context.Context, arg GetAnimeByGenreParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimeByGenre, arg.Limit, arg.Offset, arg.Genre)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeByHiAnimeId = `-- name: GetAnimeByHiAnimeId :one
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
WHERE hi_anime_id = $1
`

func (q *Queries) GetAnimeByHiAnimeId(ctx context.Context, hiAnimeID string) (Anime, error) {
	row := q.db.QueryRow(ctx, getAnimeByHiAnimeId, hiAnimeID)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const getAnimeById = `-- name: GetAnimeById :one
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
WHERE id = $1
`

func (q *Queries) GetAnimeById(ctx context.Context, id string) (Anime, error) {
	row := q.db.QueryRow(ctx, getAnimeById, id)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const getAnimeByMalId = `-- name: GetAnimeByMalId :one
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
WHERE mal_id = $1
`

func (q *Queries) GetAnimeByMalId(ctx context.Context, malID pgtype.Int4) (Anime, error) {
	row := q.db.QueryRow(ctx, getAnimeByMalId, malID)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const getAnimeByMediaType = `-- name: GetAnimeByMediaType :many
SELECT animes.id, animes.ename, animes.jname, animes.image_url, animes.genre, animes.hi_anime_id, animes.mal_id, animes.anilist_id, animes.last_episode, animes.created_at, animes.updated_at, animes.search_vector,
  anime_metadata.mal_id, anime_metadata.description, anime_metadata.main_picture_url, anime_metadata.media_type, anime_metadata.rating, anime_metadata.airing_status, anime_metadata.avg_episode_duration, anime_metadata.total_episodes, anime_metadata.studio, anime_metadata.rank, anime_metadata.mean, anime_metadata.scoringusers, anime_metadata.popularity, anime_metadata.airing_start_date, anime_metadata.airing_end_date, anime_metadata.source, anime_metadata.trailer_embed_url, anime_metadata.season_year, anime_metadata.season, anime_metadata.created_at, anime_metadata.updated_at
FROM animes
  LEFT JOIN anime_metadata ON animes.mal_id = anime_metadata.mal_id
WHERE anime_metadata.media_type = $3
ORDER BY animes.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAnimeByMediaTypeParams struct {
	Limit     int32
	Offset    int32
	MediaType MediaType
}

type GetAnimeByMediaTypeRow struct {
	ID             string
	Ename          string
	Jname          string
	ImageUrl       string
	Genre          string
	HiAnimeID      string
	MalID          pgtype.Int4
	AnilistID      pgtype.Int4
	LastEpisode    int32
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	SearchVector   interface{}
	AnimeMetadatum AnimeMetadatum
}

func (q *Queries) GetAnimeByMediaType(ctx context.Context, arg GetAnimeByMediaTypeParams) ([]GetAnimeByMediaTypeRow, error) {
	rows, err := q.db.Query(ctx, getAnimeByMediaType, arg.Limit, arg.Offset, arg.MediaType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAnimeByMediaTypeRow
	for rows.Next() {
		var i GetAnimeByMediaTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.AnimeMetadatum.MalID,
			&i.AnimeMetadatum.Description,
			&i.AnimeMetadatum.MainPictureUrl,
			&i.AnimeMetadatum.MediaType,
			&i.AnimeMetadatum.Rating,
			&i.AnimeMetadatum.AiringStatus,
			&i.AnimeMetadatum.AvgEpisodeDuration,
			&i.AnimeMetadatum.TotalEpisodes,
			&i.AnimeMetadatum.Studio,
			&i.AnimeMetadatum.Rank,
			&i.AnimeMetadatum.Mean,
			&i.AnimeMetadatum.Scoringusers,
			&i.AnimeMetadatum.Popularity,
			&i.AnimeMetadatum.AiringStartDate,
			&i.AnimeMetadatum.AiringEndDate,
			&i.AnimeMetadatum.Source,
			&i.AnimeMetadatum.TrailerEmbedUrl,
			&i.AnimeMetadatum.SeasonYear,
			&i.AnimeMetadatum.Season,
			&i.AnimeMetadatum.CreatedAt,
			&i.AnimeMetadatum.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeBySeason = `-- name: GetAnimeBySeason :many
SELECT animes.id, animes.ename, animes.jname, animes.image_url, animes.genre, animes.hi_anime_id, animes.mal_id, animes.anilist_id, animes.last_episode, animes.created_at, animes.updated_at, animes.search_vector,
  anime_metadata.mal_id, anime_metadata.description, anime_metadata.main_picture_url, anime_metadata.media_type, anime_metadata.rating, anime_metadata.airing_status, anime_metadata.avg_episode_duration, anime_metadata.total_episodes, anime_metadata.studio, anime_metadata.rank, anime_metadata.mean, anime_metadata.scoringusers, anime_metadata.popularity, anime_metadata.airing_start_date, anime_metadata.airing_end_date, anime_metadata.source, anime_metadata.trailer_embed_url, anime_metadata.season_year, anime_metadata.season, anime_metadata.created_at, anime_metadata.updated_at
FROM animes
  LEFT JOIN anime_metadata ON animes.mal_id = anime_metadata.mal_id
WHERE anime_metadata.season = $3
  AND anime_metadata.season_year = $4
ORDER BY animes.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAnimeBySeasonParams struct {
	Limit      int32
	Offset     int32
	Season     Season
	SeasonYear pgtype.Int4
}

type GetAnimeBySeasonRow struct {
	ID             string
	Ename          string
	Jname          string
	ImageUrl       string
	Genre          string
	HiAnimeID      string
	MalID          pgtype.Int4
	AnilistID      pgtype.Int4
	LastEpisode    int32
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	SearchVector   interface{}
	AnimeMetadatum AnimeMetadatum
}

func (q *Queries) GetAnimeBySeason(ctx context.Context, arg GetAnimeBySeasonParams) ([]GetAnimeBySeasonRow, error) {
	rows, err := q.db.Query(ctx, getAnimeBySeason,
		arg.Limit,
		arg.Offset,
		arg.Season,
		arg.SeasonYear,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAnimeBySeasonRow
	for rows.Next() {
		var i GetAnimeBySeasonRow
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.AnimeMetadatum.MalID,
			&i.AnimeMetadatum.Description,
			&i.AnimeMetadatum.MainPictureUrl,
			&i.AnimeMetadatum.MediaType,
			&i.AnimeMetadatum.Rating,
			&i.AnimeMetadatum.AiringStatus,
			&i.AnimeMetadatum.AvgEpisodeDuration,
			&i.AnimeMetadatum.TotalEpisodes,
			&i.AnimeMetadatum.Studio,
			&i.AnimeMetadatum.Rank,
			&i.AnimeMetadatum.Mean,
			&i.AnimeMetadatum.Scoringusers,
			&i.AnimeMetadatum.Popularity,
			&i.AnimeMetadatum.AiringStartDate,
			&i.AnimeMetadatum.AiringEndDate,
			&i.AnimeMetadatum.Source,
			&i.AnimeMetadatum.TrailerEmbedUrl,
			&i.AnimeMetadatum.SeasonYear,
			&i.AnimeMetadatum.Season,
			&i.AnimeMetadatum.CreatedAt,
			&i.AnimeMetadatum.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimesByAnilistIds = `-- name: GetAnimesByAnilistIds :many
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
WHERE anilist_id = ANY($1::int [])
ORDER BY updated_at DESC
`

func (q *Queries) GetAnimesByAnilistIds(ctx context.Context, anilistIds []int32) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimesByAnilistIds, anilistIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimesByHiAnimeIds = `-- name: GetAnimesByHiAnimeIds :many
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
WHERE hi_anime_id = ANY($1::text [])
ORDER BY updated_at DESC
`

func (q *Queries) GetAnimesByHiAnimeIds(ctx context.Context, hiAnimeIds []string) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimesByHiAnimeIds, hiAnimeIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimesByIds = `-- name: GetAnimesByIds :many
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
WHERE id = ANY($1::text [])
ORDER BY updated_at DESC
`

func (q *Queries) GetAnimesByIds(ctx context.Context, ids []string) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimesByIds, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimesByMalIds = `-- name: GetAnimesByMalIds :many
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
WHERE mal_id = ANY($1::int [])
ORDER BY updated_at DESC
`

func (q *Queries) GetAnimesByMalIds(ctx context.Context, malIds []int32) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getAnimesByMalIds, malIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountOfAnimes = `-- name: GetCountOfAnimes :one
SELECT COUNT(*) AS count
FROM animes
`

func (q *Queries) GetCountOfAnimes(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOfAnimes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRandomAnime = `-- name: GetRandomAnime :one
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomAnime(ctx context.Context) (Anime, error) {
	row := q.db.QueryRow(ctx, getRandomAnime)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const getRandomAnimeByGenre = `-- name: GetRandomAnimeByGenre :one
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
WHERE genre ILIKE '%' || $1 || '%'
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomAnimeByGenre(ctx context.Context, genre pgtype.Text) (Anime, error) {
	row := q.db.QueryRow(ctx, getRandomAnimeByGenre, genre)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.Ename,
		&i.Jname,
		&i.ImageUrl,
		&i.Genre,
		&i.HiAnimeID,
		&i.MalID,
		&i.AnilistID,
		&i.LastEpisode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const getRecentlyUpdatedAnimes = `-- name: GetRecentlyUpdatedAnimes :many
SELECT id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
FROM animes
ORDER BY updated_at DESC
LIMIT $1 OFFSET $2
`

type GetRecentlyUpdatedAnimesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetRecentlyUpdatedAnimes(ctx context.Context, arg GetRecentlyUpdatedAnimesParams) ([]Anime, error) {
	rows, err := q.db.Query(ctx, getRecentlyUpdatedAnimes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAnime = `-- name: InsertAnime :exec
INSERT INTO animes (
    ename,
    jname,
    image_url,
    genre,
    hi_anime_id,
    mal_id,
    anilist_id,
    last_episode
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
  )
RETURNING id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
`

type InsertAnimeParams struct {
	Ename       string
	Jname       string
	ImageUrl    string
	Genre       string
	HiAnimeID   string
	MalID       pgtype.Int4
	AnilistID   pgtype.Int4
	LastEpisode int32
}

func (q *Queries) InsertAnime(ctx context.Context, arg InsertAnimeParams) error {
	_, err := q.db.Exec(ctx, insertAnime,
		arg.Ename,
		arg.Jname,
		arg.ImageUrl,
		arg.Genre,
		arg.HiAnimeID,
		arg.MalID,
		arg.AnilistID,
		arg.LastEpisode,
	)
	return err
}

const insertAnimeMetadata = `-- name: InsertAnimeMetadata :exec
INSERT INTO anime_metadata (
    mal_id,
    description,
    main_picture_url,
    media_type,
    rating,
    airing_status,
    avg_episode_duration,
    total_episodes,
    studio,
    rank,
    mean,
    scoringUsers,
    popularity,
    airing_start_date,
    airing_end_date,
    source,
    trailer_embed_url,
    season_year,
    season
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19
  ) ON CONFLICT (mal_id) DO
UPDATE
SET description = EXCLUDED.description,
  main_picture_url = EXCLUDED.main_picture_url,
  media_type = EXCLUDED.media_type,
  rating = EXCLUDED.rating,
  airing_status = EXCLUDED.airing_status,
  avg_episode_duration = EXCLUDED.avg_episode_duration,
  total_episodes = EXCLUDED.total_episodes,
  studio = EXCLUDED.studio,
  rank = EXCLUDED.rank,
  mean = EXCLUDED.mean,
  scoringUsers = EXCLUDED.scoringUsers,
  popularity = EXCLUDED.popularity,
  airing_start_date = EXCLUDED.airing_start_date,
  airing_end_date = EXCLUDED.airing_end_date,
  source = EXCLUDED.source,
  trailer_embed_url = EXCLUDED.trailer_embed_url,
  season_year = EXCLUDED.season_year,
  season = EXCLUDED.season,
  updated_at = NOW()
RETURNING mal_id, description, main_picture_url, media_type, rating, airing_status, avg_episode_duration, total_episodes, studio, rank, mean, scoringusers, popularity, airing_start_date, airing_end_date, source, trailer_embed_url, season_year, season, created_at, updated_at
`

type InsertAnimeMetadataParams struct {
	MalID              int32
	Description        pgtype.Text
	MainPictureUrl     pgtype.Text
	MediaType          MediaType
	Rating             Rating
	AiringStatus       AiringStatus
	AvgEpisodeDuration pgtype.Int4
	TotalEpisodes      pgtype.Int4
	Studio             pgtype.Text
	Rank               pgtype.Int4
	Mean               pgtype.Float8
	Scoringusers       pgtype.Int4
	Popularity         pgtype.Int4
	AiringStartDate    pgtype.Text
	AiringEndDate      pgtype.Text
	Source             Source
	TrailerEmbedUrl    pgtype.Text
	SeasonYear         pgtype.Int4
	Season             Season
}

func (q *Queries) InsertAnimeMetadata(ctx context.Context, arg InsertAnimeMetadataParams) error {
	_, err := q.db.Exec(ctx, insertAnimeMetadata,
		arg.MalID,
		arg.Description,
		arg.MainPictureUrl,
		arg.MediaType,
		arg.Rating,
		arg.AiringStatus,
		arg.AvgEpisodeDuration,
		arg.TotalEpisodes,
		arg.Studio,
		arg.Rank,
		arg.Mean,
		arg.Scoringusers,
		arg.Popularity,
		arg.AiringStartDate,
		arg.AiringEndDate,
		arg.Source,
		arg.TrailerEmbedUrl,
		arg.SeasonYear,
		arg.Season,
	)
	return err
}

type InsertMultipleAnimeMetadatasParams struct {
	MalID              int32
	Description        pgtype.Text
	MainPictureUrl     pgtype.Text
	MediaType          MediaType
	Rating             Rating
	AiringStatus       AiringStatus
	AvgEpisodeDuration pgtype.Int4
	TotalEpisodes      pgtype.Int4
	Studio             pgtype.Text
	Rank               pgtype.Int4
	Mean               pgtype.Float8
	Scoringusers       pgtype.Int4
	Popularity         pgtype.Int4
	AiringStartDate    pgtype.Text
	AiringEndDate      pgtype.Text
	Source             Source
	TrailerEmbedUrl    pgtype.Text
	SeasonYear         pgtype.Int4
	Season             Season
}

type InsertMultipleAnimesParams struct {
	Ename       string
	Jname       string
	ImageUrl    string
	Genre       string
	HiAnimeID   string
	MalID       pgtype.Int4
	AnilistID   pgtype.Int4
	LastEpisode int32
}

const searchAnimes = `-- name: SearchAnimes :many
SELECT animes.id, animes.ename, animes.jname, animes.image_url, animes.genre, animes.hi_anime_id, animes.mal_id, animes.anilist_id, animes.last_episode, animes.created_at, animes.updated_at, animes.search_vector,
  anime_metadata.mal_id, anime_metadata.description, anime_metadata.main_picture_url, anime_metadata.media_type, anime_metadata.rating, anime_metadata.airing_status, anime_metadata.avg_episode_duration, anime_metadata.total_episodes, anime_metadata.studio, anime_metadata.rank, anime_metadata.mean, anime_metadata.scoringusers, anime_metadata.popularity, anime_metadata.airing_start_date, anime_metadata.airing_end_date, anime_metadata.source, anime_metadata.trailer_embed_url, anime_metadata.season_year, anime_metadata.season, anime_metadata.created_at, anime_metadata.updated_at,
  ts_rank(
    animes.search_vector,
    plainto_tsquery($3)
  ) AS query_rank
FROM animes
  LEFT JOIN anime_metadata ON animes.mal_id = anime_metadata.mal_id
WHERE (
    $3 = ''
    OR name % $3
    OR jname % $3
    OR search_vector @@ plainto_tsquery('english', $3)
  )
  AND (
    $4 = ''
    OR genre ILIKE '%' || $4 || '%'
  )
  AND animes.mal_id IS NOT NULL
ORDER BY query_rank DESC
LIMIT $1 OFFSET $2
`

type SearchAnimesParams struct {
	Limit  int32
	Offset int32
	Query  string
	Genre  interface{}
}

type SearchAnimesRow struct {
	ID             string
	Ename          string
	Jname          string
	ImageUrl       string
	Genre          string
	HiAnimeID      string
	MalID          pgtype.Int4
	AnilistID      pgtype.Int4
	LastEpisode    int32
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	SearchVector   interface{}
	AnimeMetadatum AnimeMetadatum
	QueryRank      float32
}

func (q *Queries) SearchAnimes(ctx context.Context, arg SearchAnimesParams) ([]SearchAnimesRow, error) {
	rows, err := q.db.Query(ctx, searchAnimes,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.Genre,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchAnimesRow
	for rows.Next() {
		var i SearchAnimesRow
		if err := rows.Scan(
			&i.ID,
			&i.Ename,
			&i.Jname,
			&i.ImageUrl,
			&i.Genre,
			&i.HiAnimeID,
			&i.MalID,
			&i.AnilistID,
			&i.LastEpisode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.AnimeMetadatum.MalID,
			&i.AnimeMetadatum.Description,
			&i.AnimeMetadatum.MainPictureUrl,
			&i.AnimeMetadatum.MediaType,
			&i.AnimeMetadatum.Rating,
			&i.AnimeMetadatum.AiringStatus,
			&i.AnimeMetadatum.AvgEpisodeDuration,
			&i.AnimeMetadatum.TotalEpisodes,
			&i.AnimeMetadatum.Studio,
			&i.AnimeMetadatum.Rank,
			&i.AnimeMetadatum.Mean,
			&i.AnimeMetadatum.Scoringusers,
			&i.AnimeMetadatum.Popularity,
			&i.AnimeMetadatum.AiringStartDate,
			&i.AnimeMetadatum.AiringEndDate,
			&i.AnimeMetadatum.Source,
			&i.AnimeMetadatum.TrailerEmbedUrl,
			&i.AnimeMetadatum.SeasonYear,
			&i.AnimeMetadatum.Season,
			&i.AnimeMetadatum.CreatedAt,
			&i.AnimeMetadatum.UpdatedAt,
			&i.QueryRank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAnimesCount = `-- name: SearchAnimesCount :one
SELECT COUNT(*)
FROM animes
  LEFT JOIN anime_metadata ON animes.mal_id = anime_metadata.mal_id
WHERE -- if $1 is empty, skip text search
  (
    $1 = ''
    OR name % $1
    OR jname % $1
    OR search_vector @@ plainto_tsquery('english', $1)
  ) -- if $2 is empty, skip genre filter
  AND (
    $2 = ''
    OR genre ILIKE '%' || $2 || '%'
  )
  AND animes.mal_id IS NOT NULL
`

type SearchAnimesCountParams struct {
	Query interface{}
	Genre interface{}
}

func (q *Queries) SearchAnimesCount(ctx context.Context, arg SearchAnimesCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, searchAnimesCount, arg.Query, arg.Genre)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateAnime = `-- name: UpdateAnime :exec
UPDATE animes
SET ename = $1,
  jname = $2,
  image_url = $3,
  genre = $4,
  hi_anime_id = $5,
  mal_id = $6,
  anilist_id = $7,
  last_episode = $8,
  updated_at = NOW()
WHERE id = $9
RETURNING id, ename, jname, image_url, genre, hi_anime_id, mal_id, anilist_id, last_episode, created_at, updated_at, search_vector
`

type UpdateAnimeParams struct {
	Ename       string
	Jname       string
	ImageUrl    string
	Genre       string
	HiAnimeID   string
	MalID       pgtype.Int4
	AnilistID   pgtype.Int4
	LastEpisode int32
	ID          string
}

func (q *Queries) UpdateAnime(ctx context.Context, arg UpdateAnimeParams) error {
	_, err := q.db.Exec(ctx, updateAnime,
		arg.Ename,
		arg.Jname,
		arg.ImageUrl,
		arg.Genre,
		arg.HiAnimeID,
		arg.MalID,
		arg.AnilistID,
		arg.LastEpisode,
		arg.ID,
	)
	return err
}

const updateAnimeMetadata = `-- name: UpdateAnimeMetadata :exec
UPDATE anime_metadata
SET description = $1,
  main_picture_url = $2,
  media_type = $3,
  rating = $4,
  airing_status = $5,
  avg_episode_duration = $6,
  total_episodes = $7,
  studio = $8,
  rank = $9,
  mean = $10,
  scoringUsers = $11,
  popularity = $12,
  airing_start_date = $13,
  airing_end_date = $14,
  source = $15,
  trailer_embed_url = $16,
  season_year = $17,
  season = $18,
  updated_at = NOW()
WHERE mal_id = $19
RETURNING mal_id, description, main_picture_url, media_type, rating, airing_status, avg_episode_duration, total_episodes, studio, rank, mean, scoringusers, popularity, airing_start_date, airing_end_date, source, trailer_embed_url, season_year, season, created_at, updated_at
`

type UpdateAnimeMetadataParams struct {
	Description        pgtype.Text
	MainPictureUrl     pgtype.Text
	MediaType          MediaType
	Rating             Rating
	AiringStatus       AiringStatus
	AvgEpisodeDuration pgtype.Int4
	TotalEpisodes      pgtype.Int4
	Studio             pgtype.Text
	Rank               pgtype.Int4
	Mean               pgtype.Float8
	Scoringusers       pgtype.Int4
	Popularity         pgtype.Int4
	AiringStartDate    pgtype.Text
	AiringEndDate      pgtype.Text
	Source             Source
	TrailerEmbedUrl    pgtype.Text
	SeasonYear         pgtype.Int4
	Season             Season
	MalID              int32
}

func (q *Queries) UpdateAnimeMetadata(ctx context.Context, arg UpdateAnimeMetadataParams) error {
	_, err := q.db.Exec(ctx, updateAnimeMetadata,
		arg.Description,
		arg.MainPictureUrl,
		arg.MediaType,
		arg.Rating,
		arg.AiringStatus,
		arg.AvgEpisodeDuration,
		arg.TotalEpisodes,
		arg.Studio,
		arg.Rank,
		arg.Mean,
		arg.Scoringusers,
		arg.Popularity,
		arg.AiringStartDate,
		arg.AiringEndDate,
		arg.Source,
		arg.TrailerEmbedUrl,
		arg.SeasonYear,
		arg.Season,
		arg.MalID,
	)
	return err
}
