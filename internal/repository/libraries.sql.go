// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: libraries.sql

package repository

import (
	"context"
)

const deleteLibrary = `-- name: DeleteLibrary :exec
DELETE FROM library
WHERE user_id = $1
  AND anime_id = $2
`

type DeleteLibraryParams struct {
	UserID  string
	AnimeID string
}

func (q *Queries) DeleteLibrary(ctx context.Context, arg DeleteLibraryParams) error {
	_, err := q.db.Exec(ctx, deleteLibrary, arg.UserID, arg.AnimeID)
	return err
}

const getContinueWatchingAnime = `-- name: GetContinueWatchingAnime :many
SELECT
  library.id, library.user_id, library.anime_id, library.status, library.watched_episodes, library.created_at, library.updated_at,
  animes.id, animes.ename, animes.jname, animes.image_url, animes.genre, animes.hi_anime_id, animes.mal_id, animes.anilist_id, animes.last_episode, animes.created_at, animes.updated_at, animes.search_vector
FROM
  library
  INNER JOIN animes ON animes.id = library.anime_id
WHERE
  status = 'watching'
  AND user_id = $3
  AND animes.last_episode > library.watched_episodes
ORDER BY
  animes.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetContinueWatchingAnimeParams struct {
	Limit  int32
	Offset int32
	UserID string
}

type GetContinueWatchingAnimeRow struct {
	Library Library
	Anime   Anime
}

func (q *Queries) GetContinueWatchingAnime(ctx context.Context, arg GetContinueWatchingAnimeParams) ([]GetContinueWatchingAnimeRow, error) {
	rows, err := q.db.Query(ctx, getContinueWatchingAnime, arg.Limit, arg.Offset, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContinueWatchingAnimeRow
	for rows.Next() {
		var i GetContinueWatchingAnimeRow
		if err := rows.Scan(
			&i.Library.ID,
			&i.Library.UserID,
			&i.Library.AnimeID,
			&i.Library.Status,
			&i.Library.WatchedEpisodes,
			&i.Library.CreatedAt,
			&i.Library.UpdatedAt,
			&i.Anime.ID,
			&i.Anime.Ename,
			&i.Anime.Jname,
			&i.Anime.ImageUrl,
			&i.Anime.Genre,
			&i.Anime.HiAnimeID,
			&i.Anime.MalID,
			&i.Anime.AnilistID,
			&i.Anime.LastEpisode,
			&i.Anime.CreatedAt,
			&i.Anime.UpdatedAt,
			&i.Anime.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContinueWatchingAnimeCount = `-- name: GetContinueWatchingAnimeCount :one
SELECT
  COUNT(*)
FROM
  library
  INNER JOIN animes ON animes.id = library.anime_id
WHERE
  status = 'watching'
  AND user_id = $1
  AND animes.last_episode > library.watched_episodes
`

func (q *Queries) GetContinueWatchingAnimeCount(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, getContinueWatchingAnimeCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLibrary = `-- name: GetLibrary :many
SELECT
  library.id, library.user_id, library.anime_id, library.status, library.watched_episodes, library.created_at, library.updated_at,
  animes.id, animes.ename, animes.jname, animes.image_url, animes.genre, animes.hi_anime_id, animes.mal_id, animes.anilist_id, animes.last_episode, animes.created_at, animes.updated_at, animes.search_vector
FROM
  library
  INNER JOIN animes ON animes.id = library.anime_id
WHERE
  library.user_id = $3
  AND library.status = $4
ORDER BY
  library.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetLibraryParams struct {
	Limit  int32
	Offset int32
	UserID string
	Status LibraryStatus
}

type GetLibraryRow struct {
	Library Library
	Anime   Anime
}

func (q *Queries) GetLibrary(ctx context.Context, arg GetLibraryParams) ([]GetLibraryRow, error) {
	rows, err := q.db.Query(ctx, getLibrary,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLibraryRow
	for rows.Next() {
		var i GetLibraryRow
		if err := rows.Scan(
			&i.Library.ID,
			&i.Library.UserID,
			&i.Library.AnimeID,
			&i.Library.Status,
			&i.Library.WatchedEpisodes,
			&i.Library.CreatedAt,
			&i.Library.UpdatedAt,
			&i.Anime.ID,
			&i.Anime.Ename,
			&i.Anime.Jname,
			&i.Anime.ImageUrl,
			&i.Anime.Genre,
			&i.Anime.HiAnimeID,
			&i.Anime.MalID,
			&i.Anime.AnilistID,
			&i.Anime.LastEpisode,
			&i.Anime.CreatedAt,
			&i.Anime.UpdatedAt,
			&i.Anime.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLibraryByID = `-- name: GetLibraryByID :one
SELECT
  library.id, library.user_id, library.anime_id, library.status, library.watched_episodes, library.created_at, library.updated_at,
  animes.id, animes.ename, animes.jname, animes.image_url, animes.genre, animes.hi_anime_id, animes.mal_id, animes.anilist_id, animes.last_episode, animes.created_at, animes.updated_at, animes.search_vector
FROM
  library
  INNER JOIN animes ON animes.id = library.anime_id
WHERE
  library.id = $1
`

type GetLibraryByIDRow struct {
	Library Library
	Anime   Anime
}

func (q *Queries) GetLibraryByID(ctx context.Context, id string) (GetLibraryByIDRow, error) {
	row := q.db.QueryRow(ctx, getLibraryByID, id)
	var i GetLibraryByIDRow
	err := row.Scan(
		&i.Library.ID,
		&i.Library.UserID,
		&i.Library.AnimeID,
		&i.Library.Status,
		&i.Library.WatchedEpisodes,
		&i.Library.CreatedAt,
		&i.Library.UpdatedAt,
		&i.Anime.ID,
		&i.Anime.Ename,
		&i.Anime.Jname,
		&i.Anime.ImageUrl,
		&i.Anime.Genre,
		&i.Anime.HiAnimeID,
		&i.Anime.MalID,
		&i.Anime.AnilistID,
		&i.Anime.LastEpisode,
		&i.Anime.CreatedAt,
		&i.Anime.UpdatedAt,
		&i.Anime.SearchVector,
	)
	return i, err
}

const getLibraryCount = `-- name: GetLibraryCount :one
SELECT
  COUNT(*)
FROM
  library
WHERE
  user_id = $1
  AND status = $2
`

type GetLibraryCountParams struct {
	UserID string
	Status LibraryStatus
}

func (q *Queries) GetLibraryCount(ctx context.Context, arg GetLibraryCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getLibraryCount, arg.UserID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLibraryOfUserByAnimeID = `-- name: GetLibraryOfUserByAnimeID :one
SELECT
  library.id, library.user_id, library.anime_id, library.status, library.watched_episodes, library.created_at, library.updated_at,
  animes.id, animes.ename, animes.jname, animes.image_url, animes.genre, animes.hi_anime_id, animes.mal_id, animes.anilist_id, animes.last_episode, animes.created_at, animes.updated_at, animes.search_vector
FROM
  library
  INNER JOIN animes ON animes.id = library.anime_id
WHERE
  library.user_id = $1
  AND library.anime_id = $2
`

type GetLibraryOfUserByAnimeIDParams struct {
	UserID  string
	AnimeID string
}

type GetLibraryOfUserByAnimeIDRow struct {
	Library Library
	Anime   Anime
}

func (q *Queries) GetLibraryOfUserByAnimeID(ctx context.Context, arg GetLibraryOfUserByAnimeIDParams) (GetLibraryOfUserByAnimeIDRow, error) {
	row := q.db.QueryRow(ctx, getLibraryOfUserByAnimeID, arg.UserID, arg.AnimeID)
	var i GetLibraryOfUserByAnimeIDRow
	err := row.Scan(
		&i.Library.ID,
		&i.Library.UserID,
		&i.Library.AnimeID,
		&i.Library.Status,
		&i.Library.WatchedEpisodes,
		&i.Library.CreatedAt,
		&i.Library.UpdatedAt,
		&i.Anime.ID,
		&i.Anime.Ename,
		&i.Anime.Jname,
		&i.Anime.ImageUrl,
		&i.Anime.Genre,
		&i.Anime.HiAnimeID,
		&i.Anime.MalID,
		&i.Anime.AnilistID,
		&i.Anime.LastEpisode,
		&i.Anime.CreatedAt,
		&i.Anime.UpdatedAt,
		&i.Anime.SearchVector,
	)
	return i, err
}

const getPlanToWatchAnime = `-- name: GetPlanToWatchAnime :many
SELECT
  library.id, library.user_id, library.anime_id, library.status, library.watched_episodes, library.created_at, library.updated_at,
  animes.id, animes.ename, animes.jname, animes.image_url, animes.genre, animes.hi_anime_id, animes.mal_id, animes.anilist_id, animes.last_episode, animes.created_at, animes.updated_at, animes.search_vector
FROM
  library
  INNER JOIN animes ON animes.id = library.anime_id
WHERE
  status = 'planning'
  AND user_id = $3
  AND animes.last_episode > library.watched_episodes
ORDER BY
  animes.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetPlanToWatchAnimeParams struct {
	Limit  int32
	Offset int32
	UserID string
}

type GetPlanToWatchAnimeRow struct {
	Library Library
	Anime   Anime
}

func (q *Queries) GetPlanToWatchAnime(ctx context.Context, arg GetPlanToWatchAnimeParams) ([]GetPlanToWatchAnimeRow, error) {
	rows, err := q.db.Query(ctx, getPlanToWatchAnime, arg.Limit, arg.Offset, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlanToWatchAnimeRow
	for rows.Next() {
		var i GetPlanToWatchAnimeRow
		if err := rows.Scan(
			&i.Library.ID,
			&i.Library.UserID,
			&i.Library.AnimeID,
			&i.Library.Status,
			&i.Library.WatchedEpisodes,
			&i.Library.CreatedAt,
			&i.Library.UpdatedAt,
			&i.Anime.ID,
			&i.Anime.Ename,
			&i.Anime.Jname,
			&i.Anime.ImageUrl,
			&i.Anime.Genre,
			&i.Anime.HiAnimeID,
			&i.Anime.MalID,
			&i.Anime.AnilistID,
			&i.Anime.LastEpisode,
			&i.Anime.CreatedAt,
			&i.Anime.UpdatedAt,
			&i.Anime.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanToWatchAnimeCount = `-- name: GetPlanToWatchAnimeCount :one
SELECT
  COUNT(*)
FROM
  library
  INNER JOIN animes ON animes.id = library.anime_id
WHERE
  status = 'planning'
  AND user_id = $1
  AND animes.last_episode > library.watched_episodes
`

func (q *Queries) GetPlanToWatchAnimeCount(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, getPlanToWatchAnimeCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const upsertLibrary = `-- name: UpsertLibrary :one
INSERT INTO library(user_id, anime_id, status, watched_episodes)
  VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, anime_id)
  DO UPDATE SET
    status = EXCLUDED.status,
    watched_episodes = EXCLUDED.watched_episodes,
    updated_at = NOW()
  RETURNING
    id, user_id, anime_id, status, watched_episodes, created_at, updated_at
`

type UpsertLibraryParams struct {
	UserID          string
	AnimeID         string
	Status          LibraryStatus
	WatchedEpisodes int32
}

func (q *Queries) UpsertLibrary(ctx context.Context, arg UpsertLibraryParams) (Library, error) {
	row := q.db.QueryRow(ctx, upsertLibrary,
		arg.UserID,
		arg.AnimeID,
		arg.Status,
		arg.WatchedEpisodes,
	)
	var i Library
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AnimeID,
		&i.Status,
		&i.WatchedEpisodes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
